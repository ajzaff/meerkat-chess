package com.alanjz.meerkat.moves

import com.alanjz.meerkat.position.mutable.MaskNode
import com.alanjz.meerkat.util.numerics.BitMask
import com.alanjz.meerkat.util.numerics.BitMask._

class RookMover(val node : MaskNode) extends IntermediateMover {

  /**
   * Returns all possible moves regardless of legality
   * (Or pseudo-legality).
   *
   * These are specifically attacking moves.
   * This does not include castling, or pawn advances.
   *
   * @param pieces the pieces mask.
   * @return the attacks possible by this piece.
   */
  override def getAttacks(pieces : BitMask): BitMask = {
    var rooks = pieces
    var moves = BitMask.empty

    // All pieces.
    val allPieces = node.activePieces | node.inactivePieces

    while(rooks != BitMask.empty) {

      // Scan for the index of the LS bishop.
      val lsb = BitMask.bitScanForward(rooks)

      // Get the relevant rays.
      val northRay = BitMask.Ray.north(lsb)
      val eastRay = BitMask.Ray.east(lsb)
      val southRay = BitMask.Ray.south(lsb)
      val westRay = BitMask.Ray.west(lsb)

      // Get some intersections.
      val eastMSB = BitMask.bitScanReverse(eastRay & allPieces)
      val southLSB = BitMask.bitScanForward(southRay & allPieces)
      val westLSB = BitMask.bitScanForward(northRay & allPieces)
      val northMSB = BitMask.bitScanReverse(northRay & allPieces)

      // Get the combo rays.
      val northeastCombo =
        if(westLSB < 0) northRay
        else northRay ^ BitMask.Ray.northeast(westLSB)
      val southeastCombo =
        if(eastMSB < 0) eastRay
        else eastRay ^ BitMask.Ray.southeast(eastMSB)
      val southwestCombo =
        if(southLSB < 0) southRay
        else southRay ^ BitMask.Ray.southwest(southLSB)
      val northwestCombo =
        if(northMSB < 0) westRay
        else westRay ^ BitMask.Ray.northwest(northMSB)

      // Get all moves for this bishop.
      moves = moves | northeastCombo | southeastCombo | southwestCombo | northwestCombo

      // The twos-decrement removes this bishop.
      rooks &= (rooks-1)
    }

    // Return moves.
    moves
  }

  /**
   * Gets all pseudo-legal moves generated by this mover.
   * @return all pseudo-legal moves and captures.
   */
  override def getPseudos: BitMask = {
    val active = node.activePieces

    // Return moves.
    getAttacks(node.activeRooks) & ~active
  }

  /**
   * Serializes the pseudo-legal moves.
   * @return a list of pseudo-legal moves of the appropriate type.
   */
  override def mkList: List[Move] = ???
}

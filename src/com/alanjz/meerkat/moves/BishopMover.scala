package com.alanjz.meerkat.moves

import com.alanjz.meerkat.moves.Move.{BishopCapture, BishopMove}
import com.alanjz.meerkat.position.mutable.MaskNode
import com.alanjz.meerkat.util.numerics.BitMask
import com.alanjz.meerkat.util.numerics.BitMask.BitMask
import com.alanjz.meerkat.util.numerics.BitMask.BitMask

class BishopMover(val node : MaskNode) extends IntermediateMover {
  /**
   * Returns all possible moves regardless of legality
   * (Or pseudo-legality).
   *
   * These are specifically attacking moves.
   * This does not include castling, or pawn advances.
   *
   * @param pieces the pieces mask.
   * @return the attacks possible by this piece.
   */
  override def getAttacks(pieces : BitMask): BitMask = {
    var bishops = pieces
    var moves = BitMask.empty

    // All pieces.
    val allPieces = node.allPieces

    while(bishops != BitMask.empty) {

      // Scan for the index of the LS bishop.
      val lsb = BitMask.bitScanForward(bishops)

      // Get the relevant rays.
      val northeastRay = BitMask.Ray.northeast(lsb)
      val southeastRay = BitMask.Ray.southeast(lsb)
      val southwestRay = BitMask.Ray.southwest(lsb)
      val northwestRay = BitMask.Ray.northwest(lsb)

      // Get the LSB of some intersections.
      val southeastMSB = BitMask.bitScanReverse(southeastRay & allPieces)
      val southwestMSB = BitMask.bitScanReverse(southwestRay & allPieces)
      val northeastLSB = BitMask.bitScanForward(northeastRay & allPieces)
      val northwestLSB = BitMask.bitScanForward(northwestRay & allPieces)

      // Get the combo rays.
      val northeastCombo =
        if(northeastLSB < 0) northeastRay
        else northeastRay ^ BitMask.Ray.northeast(northeastLSB)
      val southeastCombo =
        if(southeastMSB < 0) southeastRay
        else southeastRay ^ BitMask.Ray.southeast(southeastMSB)
      val southwestCombo =
        if(southwestMSB < 0) southwestRay
        else southwestRay ^ BitMask.Ray.southwest(southwestMSB)
      val northwestCombo =
        if(northwestLSB < 0) northwestRay
        else northwestRay ^ BitMask.Ray.northwest(northwestLSB)

      // Get all moves for this bishop.
      moves = moves | northeastCombo | southeastCombo | southwestCombo | northwestCombo

      // The twos-decrement removes this bishop.
      bishops &= (bishops-1)
    }

    // Return moves.
    moves
  }

  /**
   * Gets all pseudo-legal moves generated by this mover.
   * @return all pseudo-legal moves and captures.
   */
  override def getPseudos: BitMask = {
    val active = node.activePieces

    // Return moves.
    getAttacks(node.activeBishops) & ~active
  }

  /**
   * Serializes the pseudo-legal moves.
   * @return a list of pseudo-legal moves of the appropriate type.
   */
  override def mkList: List[Move] = {
    val builder = List.newBuilder[Move]
    var moves = getPseudos
    val activeBishops = node.activeBishops

    while(moves != BitMask.empty) {
      val lsb = BitMask.bitScanForward(moves)
      var sources = getAttacks(1l << lsb) & activeBishops

      while(sources != BitMask.empty) {
        val source = BitMask.bitScanForward(sources)
        if(node.empty(lsb)) {
          builder += BishopMove(source, lsb)
        }
        else {
          builder += BishopCapture(source, lsb, node.at(lsb).get)
        }
        sources &= (sources-1)
      }
      moves &= (moves-1)
    }

    builder.result()
  }
}

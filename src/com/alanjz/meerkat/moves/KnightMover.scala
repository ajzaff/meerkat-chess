package com.alanjz.meerkat.moves

import com.alanjz.meerkat.position.mutable.MaskNode
import com.alanjz.meerkat.util.numerics.BitMask
import com.alanjz.meerkat.util.numerics.BitMask.{BitMask, File, Rank}

/**
 * Created by alan on 12/13/14.
 */
class KnightMover(val node : MaskNode) extends IntermediateMover {
  /**
   * Returns all possible moves regardless of legality
   * (Or pseudo-legality).
   *
   * These are specifically attacking moves.
   * This does not include castling, or pawn advances.
   *
   * @return the attacks possible by this piece.
   */
  override def getAttacks: BitMask = {

    // get active knights.
    val knights = node.activeKnights

    // initialize moves.
    var moves = BitMask.empty

    // 1:00
    moves |= (knights & ~Rank._7 & ~Rank._8 & ~File.H) << 17

    // 2:00
    moves |= (knights & ~Rank._8 & ~File.G & ~File.H) << 10

    // 4:00
    moves |= (knights & ~Rank._1 & ~File.G & ~File.H) >> 6

    // 5:00
    moves |= (knights & ~Rank._1 & ~Rank._2 & ~File.H) >> 15

    // 7:00
    moves |= (knights & ~Rank._1 & ~Rank._2 & ~File.A) >> 17

    // 8:00
    moves |= (knights & ~Rank._1 & ~File.A & ~File.B) >> 10

    // 10:00
    moves |= (knights & ~Rank._8 & ~File.A & ~File.B) << 6

    // 11:00
    moves |= (knights & ~Rank._8 & ~Rank._7 & ~File.A) << 15

    // return moves.
    moves
  }

  /**
   * Gets all pseudo-legal moves generated by this mover.
   * @return all pseudo-legal moves and captures.
   */
  override def getPseudos: BitMask = {

    val active = node.activePieces
    val inactive = node.inactivePieces

    // return moves.
    getAttacks & inactive & ~active
  }

}
